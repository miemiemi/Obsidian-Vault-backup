
预处理 -> 编译 -> 汇编 -> 链接 -> 执行
Talk is cheap, show me the code!

# 预处理

- 预处理 = 文本粘贴
- 头文件是如何找到的?
    -方法: 阅读工具的日志(查看是否支持verbose, log等选项)
- 类函数宏
    - 预处理阶段只进行文本粘贴, 不求值
    - 小心优先级!
        - 好的编程习惯 -> 总是用括号包围参数
    - 小心副作用!
        - 好的编程习惯 -> 一个参数尽量不要展开多次
        - 如何实现?
        ```
        #define max(a, b) ({ int x = a; int y = b; x > y ? x : y; })
        ```
- 预处理的其他工作
    - 连接因断行符(行尾的\)而拆分的字符串
    - 处理条件编译 #ifdef/#else/#endif
    - 字符串化 #
    - 标识符连接 ##
- IOCCC(国际混乱C代码大赛)
    - 套路: 借助预处理机制编写不可读代码

# 编译

- 编译是一个比较复杂的过程
    - 词法分析 -> 语法分析 -> 语义分析 -> 中间代码生成 -> 优化 -> 目标代码生成
    - 借助合适的工具(clang), 我们来看看每一个阶段都在做什么
        - clang功能上等价于gcc
    - 词法分析
        - 识别并记录源文件中的每一个token
            - 标识符, 关键字, 常数, 字符串, 运算符, 大括号, 分号…
            - 还记录了token的位置(文件名:行号:列号)
            - C代码 = 文本: 本质上是一个文本匹配程序
    - 语法分析
        - 按照C语言的语法将识别出来的token组织成树状结构
            - AST(Abstract Syntax Tree), 可以反映出源程序的层次结构
            - 报告语法错误, 例如漏了分号
    - 语义分析
        - 按照C语言的语义确定AST中每个表达式的类型
            - 相容的类型将根据C语言标准规范进行类型转换
                - 算术类型转换
            - 报告语义错误
                - 未定义的引用
                - 运算符的操作数类型不匹配(如struct + int)
                - 函数调用参数的类型和数量不匹配
                - …
- 但大多数编译器并没有把词法分析, 语法分析, 语义分析严格按阶段进行
    - clang的-ast-dump把语义信息也一起输出了
    man clang可以得知clang的阶段划分
- 中间代码生成
    - 中间代码(也称中间表示, IR) = 一种编译器定义的, 面向编译场景的指令集
        - 本质上是编译过程中的一个抽象层, 基于抽象层进行优化很容易
        - 可以支持多种源语言和目标语言(硬件指令集)
    - clang使用的中间代码叫LLVM IR, gcc的叫GIMPLE
        - 我们不需要理解其中的细节, 研究它是编译专家的事情
        - 知道一些基本概念, 会连蒙带猜看一看即可(可RTFM了解更多)
- 优化
    - C语言标准对程序执行的要求很宽松
        - 可以严格按照语句的语义来执行(严格的状态转移)
        - 也可以不严格, 但需要满足程序的可观测行为(observable behavior of the program, C99 5.1.2.3节第6点)的一致性
            - 对volatile修饰变量的访问需要严格执行
            - 程序结束时, 写入文件的数据需要与严格执行时一致
            - 交互式设备的输入输出(stdio.h)需要与严格执行时一致
    - 这给编译器优化提供了非常广阔的空间
        - 也是因为太广阔, 以至于编译器里面有很多bug
        - 理论上来说, “判断任意两个程序的可观测行为是否一致”是不可判定的
            - 如果这个问题可判定, 那么借助它可判定图灵停机问题(阅读材料)
    - 优化，例: 常数传播

















