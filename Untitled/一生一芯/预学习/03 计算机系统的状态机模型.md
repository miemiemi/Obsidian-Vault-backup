# 状态机模型
- 一个不是特别严谨的定义
    - 状态集合S = {S1, S2, ...}
    - 激励事件
    - 状态转移规则
        - 描述每个状态在不同激励事件下的次态(next state)
    - 初始状态S0 ∈ S
- 计算机系统都是状态机!
    - 考虑一个简单的计算机系统: 程序直接在CPU上运行(无操作系统)
    ```
               +-------------------+
               |      Program      |
               +-------------------+
               |        ISA        |
               +-------------------+
               |        CPU        |
               +-------------------+
    ```
    - 这三个抽象层次(程序, 指令集, CPU)都可以用状态机来理解!

# 程序

- 大家眼中的C程序
    - C语言的组成
        - 变量 - 计算的对象
        - 语句 - 计算的操作流程
        - 输入输出函数 - 让变量与外界交互
- C程序的状态机模型
    - 状态集合S = {<V, PC>}
        - V = {v1, v2, v3, ...} = 程序中所有变量的取值
            - 包括全局变量和局部变量
        - PC = 程序计数器 = 当前执行的语句位置
    - 激励事件
        - 执行PC指向的语句
    - 状态转移规则
        - 语句的语义(semantics)
    - 初始状态S0 = <V0, main函数的第一条语句>
- 但好像还有很多细节没完全搞清楚
    ```
    x = (-b+sqrt(b*b-4*a*c))/(2*a);
    ```
    - 如果执行的语句很复杂, 应该如何理解?
        - 可以将复杂语句拆分成若干简单语句, 从简单语句理解状态转移
        - 确实有工具做这件事: C Intermediate Language
    - 语句的语义是谁说了算
        - FM: C语言标准手册 ✅
            - 权威严谨, 但对新手来说不好读
            - 追根溯源的唯一选择
        - 例: 真的是从main()第一条语句开始执行吗?
        - 看看FM怎么说
            - 有一个概念叫执行环境, 原来是它来调用一个专门的C函数
            - 执行环境有两种: 独立环境(freestanding)和宿主环境(hosted)
            - 程序的执行
                - 一些语句的操作会引起副作用, 从而导致执行环境状态的变化
                - C程序确实是一个状态机
                - 虽然main()函数不是真正的程序入口, 但用来理解状态机模型是足够的
    - RTFM
        - C语言标准手册精确定义了C语言的每一处细节
            - 想了解一切细节发生的依据, RTFM是唯一正确的选择
        - 大部分C语言的材料都没有覆盖到所有细节, 因此不要迷信书籍和博客
            - 书籍和博客的作者对C语言的认识, 比不上C语言标准的制定者
        - 正确的学习方法:
            - 通过书籍入门
            - 把书籍丢掉
            - 通过手册成为专业人士

# CPU

- CPU = 数字逻辑电路 = 状态机
    - CPU如何设计是微结构层次的话题
    - 但无论怎么设计, 总归是一个数字逻辑电路
        - 数字逻辑电路 = 组合逻辑电路 + 时序逻辑电路
    - 状态集合S = {<时序逻辑元件的值>}
        - 具体包括寄存器, 存储器, 触发器等
    - 激励事件
        - 组合逻辑
    - 状态转移规则
        - 由设计中的组合逻辑电路决定
        - 依据: 架构师的设计文档
    - 初始状态S0 = <复位时时序逻辑元件的值>
    - 例: Johnson计数器

# 指令集

- 指令集是什么?
    - 课本上通常会给一个抽象的定义, 例如
        - 指令集是软件和硬件之间的接口
    - 我们来进行这样的比喻: 指令集是一本手册规范, 使得
        - 指令集手册定义了CPU执行指令的行为
        - 就好比C语言标准手册定义了C程序执行语句的行为
- 指令集和CPU是不同层次的概念
- 开放指令集和开源CPU也是不同层次的概念
- 自测题
    - X86是一种指令集规范? Y
    - 苹果M1牛是因为采用了ARM指令集? N
    - 国产处理器的实现和国外还有差距? Y
    - 几个月就可以定义一个新指令集? Y
    - 根据指令集规范实现一个处理器不容易? Y
    - 给定一个指令集只有一种处理器实现? N
    - 可以给一个处理器实现换一个指令集? Y
- 《RISC-V Reader》是一本科普读物, 并不是官方手册(书的前言)
    - 《RISC-V Reader》的作者(David Patterson & Andrew Waterman)也来自RISC-V团队, 书的质量并不低
    - 通过《RISC-V读本》学习RISC-V
    - 通过《RISC-V Instruction Set Manual》了解所有最新的细节

- 指令集手册也定义了一个状态机!
    - 状态集合S = {<R, M>}
        - R = {PC, x0, x1, x2, ...} 
            - RISC-V手册 -> 2.1 Programmers’ Model for Base Integer ISA
            - PC = 程序计数器 = 当前执行的指令位置
        - M = 内存
            - RISC-V手册 -> 1.4 Memory
    - 激励事件: 
        - 执行PC指向的指令
    - 状态转移规则: 
        - 指令的语义(semantics)
    - 初始状态S0 = <R0, M0>
- 用C程序理解指令
    - 指令的两种表示: 符号化表示(面向程序员)和编码表示(面向电路设计)
- 指令集手册不仅仅包含指令
    - 指令集体系结构(Instruction Set Architecture, ISA), 还有
        - 输入输出
        - 系统状态
        - 中断异常
        - 虚存管理
        - 内存模型
    - 指令集手册通过定义状态机进行状态转移的规则, 来描述一台抽象计算机所具备的, 程序可以使用的功能


# 程序如何在计算机上运行

- 编译
    - 编译器的工作: 将C程序的状态机S_c翻译成指令集的状态机S_isa
        - fstate: {PC_c, v1, v2, v3, ...} -> {R, M} (R中包含PC_isa)
        - fcompile: {语句} -> {指令序列}
        - 使得
            ```
            fstate(next(S_c, 语句))
            = next(fstate(S_c), fcompile(语句))
            = next(S_isa, 指令序列)
            ```
        - 说人话: C程序执行一条语句后的状态, 与抽象计算机执行编译后的指令序列后的状态，语义上是等价的

- 汇编
    - 汇编 = 指令的符号化表示
    - 汇编程序 = 指令集的状态机
    - 汇编课 = RTFM(指令集手册)

- 微结构设计
    - 微结构设计的工作: 将指令集的状态机S_isa用电路来实现成CPU的状态机S_cpu
        - fstate: {R, M} -> {时序逻辑电路}
        - fuarch: {指令} -> {组合逻辑电路}
        - 说人话: 抽象计算机执行一条指令后的状态, 与CPU在根据指令语义设计出的组合逻辑电路控制下的次态，语义上是等价的
- 程序如何在计算机上运行
    - 程序和指令集都没有实体, 计算机的实体是电路, 如何联系它们?
    - 根据指令集手册的功能描述, 用画一张CPU的电路图 -> 微结构设计
    用RTL代码描述CPU电路图 -> RTL设计
    - 将RTL代码生成版图文件 -> 后端物理设计
    - 根据版图文件生产出芯片 -> 制造生产
    - 编写程序 -> 软件编程
    - 将程序翻译成指令集手册中描述的指令序列 -> 编译
    - 程序在CPU上执行 = 指令序列控制CPU芯片电路进行状态转移
        - 三个状态机产生联系: S_c ~ S_isa ~ S_cpu
- 一句话就能说清楚的事情, 为什么要搞那么复杂?
    - 有些概念和问题从状态机模型思考可以给我们带来新的启发
    - 不过最重要的是给大家传达一种观念
        - 机器永远是对的
    - 计算机系统的行为是按照官方手册的描述精确发生的
        - 每一次状态转移都是手册依据的
        - 如果你不理解计算机系统的行为, 很大概率是因为你不了解相关手册中的某些关键细节
            - “永远”的理解: 商业产品也会有bug(Intel奔腾的fdiv bug), 但你恰好遇上的概率很小






























