**本讲内容**：个人/课程简介、操作系统的发展历史，回答三个问题：

#   (Why): 为什么要学操作系统？

-  学过微积分以后，再看为什么要学微积分
	- 微积分的几个重要主题
		- 启蒙、应用与挑战 (Newton 时代)
			-   机械论世界观 (模型驱动的系统分析)
			-   数学是理解世界的 “基本工具”：导数、微积分基本定理、……
		-  严格化与公理化 (Cauchy 时代)
			-   各种卡出的 bug (Weierstrass 函数、Peano 曲线……)
		-   大规模问题的数值计算 (von Neumann 时代)
			-   优化、有限元、PID……
			-   AI 是未来人类社会的 “基本工具”
		- 三个主题应该根据学科特点各有侧重
			-   我自己的感受：学了很多，但好像都没学懂
- 为什么要学 “任何东西”？
	- 重走从无到有的发现历程
		-   基本思想、基本方法、里程碑、走过的弯路
		-   最终目的：应用/创新 (做题得分不是目的而是手段)
		    -   如果只是记得几个结论，那 ChatGPT 已经做得很好了
	- 学习 “任何东西” 的现代方法

	-   使用辅助工具加速探索
	    -   数值/符号计算：numpy, sympy, sage, Mathematica, ...
	    -   可视化：matplotlib
	        -   All-in-one: [Jupyter](http://jupyter.org/) (2017 ACM Software System Award)
	        -   Life is short; you need Python
	-   (正好我有一个微积分相关的案例)
	
- 为什么学习操作系统？

	- 你体内的 “编程力量” 尚未完全觉醒
		-  每天都在用的东西，你还没搞明白
			-   为什么能创建窗口？[为什么 Ctrl-C 有时不能退出程序](https://stackoverflow.blog/2017/05/23/stack-overflow-helping-one-million-developers-exit-vim/)？
			-   为什么有的程序能把组里服务器的 128 个 CPU 用满？
		-   你每天都在用的东西，你实现不出来
			-   浏览器、编译器、IDE、游戏/外挂、杀毒软件、病毒……
	- 《操作系统》带你补完 “编程” 的技术体系
		-  悟性好：学完课程就在系统方向 “毕业”
			-   具有编写一切 “能写出来” 程序的能力 (具备阅读论文的能力)
		-   悟性差：内力大增
			-   可能工作中的某一天想起上课提及的内容


#  (What): 到底什么是操作系统？

```
Operating System: A body of software, in fact, that is responsible for _making it easy to run programs_ (even allowing you to seemingly run many at the same time), allowing programs to share memory, enabling programs to interact with devices, and other fun stuff like that. (OSTEP)
```

很多疑点

-   “programs” 就完了？那么多复杂的程序呢！
-   “shared memory, interact with devices, ...”？

## 理解操作系统

“精准” 的教科书定义毫无意义 (但作者得被迫去写)

-   定义是 “全部” 的一个极简表达
    -   如果只想 “了解”，那可以读一下定义
    -   如果想学习操作系统，就必须理解 “全部”

操作系统 “全部” 的 overview：

-   操作系统如何从一开始变成现在这样的？
-   三个重要的线索
    -   硬件 (计算机)
    -   软件 (程序)
    -   操作系统 (管理硬件和软件的软件)

## 复习：理解计算机硬件 (电路)

前导知识：数字逻辑电路/计算机系统基础

-   一个极简的公理系统 (导线、时钟、逻辑门、触发器)
-   建立在公理体系上的数字系统设计 (包括计算机)
    -   前导课程目标：能根据需求实现数字系统

### Logisim Demo

数字电路模拟器

-   基本构件：wire, reg, NAND, NOT, AND, NOR
-   每一个时钟周期
    -   先计算 wire 的值
    -   在周期结束时把值锁存至 reg

会编程，你就拥有全世界！

-   同样的方式可以模拟任何数字系统 (包括计算机系统)
-   同时还体验了 UNIX 哲学
    -   Make each program do one thing well
    -   Expect the output of every program to become the input to another

## 复习：理解计算机软件 (程序)


前导课程：C 程序设计/计算机系统基础

-   高级语言代码 → 指令序列 → 二进制文件 → 处理器执行
    -   前导课程目标：能将需求实现；掌握工具使用；阅读汇编指令

## 理解操作系统

本课程讨论狭义的操作系统

-   操作系统：硬件和软件的中间层
    -   对单机 (多处理器) 作出抽象
    -   支撑多个程序执行
-   学术界谈论的 “操作系统” 是更广义的 “System”
    -   例子：对多台计算机抽象 (分布式系统)

---

理解操作系统

-   理解硬件 (计算机) 和软件 (程序) 的发展历史
-   夹在中间的就是操作系统

## ENIAC: 1946.2.14

“图灵机” 的数字电路实现

-   执行完一条指令后，可以根据结果跳转到任意一条指令 (用物理线路 “hard-wire”)
-   重编程需要重新接线：[Emulator](https://www.cs.drexel.edu/~bls96/eniac/) and [Programming the ENIAC](https://ieeexplore.ieee.org/stamp/stamp.jsp?tp=&arnumber=8467000)

## 1940s 的计算机硬件

电子计算机的实现

-   逻辑门：[真空电子管](https://www.bilibili.com/video/av59005720)
-   存储器：延迟线 (delay lines)
-   输入/输出：打孔纸带/指示灯

## 1940s 的计算机软件

打印平方数、素数表、计算弹道……

-   解释了《程序设计》教课书上经典习题的来源
    -   (是时候改一改了)
-   大家还在和真正的 “bugs” 战斗

## 1940s 的操作系统

> 没有操作系统。

能把程序放上去就很了不起了

-   程序直接用指令操作硬件
-   不需要画蛇添足的程序来管理它

## 1950s 的计算机硬件

更快更小的逻辑门 (晶体管)、更大的内存 (磁芯)、丰富的 I/O 设备

-   I/O 设备的速度已经严重低于处理器的速度，中断机制出现 (1953)

## 1950s 的计算机软件

更复杂的通用的数值计算

-   高级语言和 API 诞生 (Fortran, 1957)：一行代码，一张卡片
    -   80 行的规范沿用至今 (细节：打印机会印刷本行代码)

## 1950s 的计算机软件 (cont'd)

Fortran 已经 “足够好用”

-   自然科学、工程机械、军事……对计算机的需求暴涨

## 1950s 的操作系统

> 库函数 + 管理程序排队运行的调度代码。

写程序 (戳纸带)、跑程序都是非常费事的

-   计算机非常贵 ($50,000−$1,000,000$50,000−$1,000,000)，一个学校只有一台
-   算力成为一种服务：多用户轮流共享计算机，operator 负责调度

---

操作系统的概念开始形成

-   操作 (operate) 任务 (jobs) 的系统 (system)
    -   “批处理系统” = 程序的自动切换 (换卡) + 库函数 API
    -   Disk Operating Systems (DOS)
        -   操作系统中开始出现 “设备”、“文件”、“任务” 等对象和 API

## 1960s 的计算机硬件

集成电路、总线出现

-   更快的处理器
-   更快、更大的内存；虚拟存储出现
    -   可以同时载入多个程序而不用 “换卡” 了
-   更丰富的 I/O 设备；完善的中断/异常机制

## 1960s 的计算机软件

更多的高级语言和编译器出现

-   COBOL (1960), APL (1962), BASIC (1965)
    -   Bill Gates 和 Paul Allen 在 1975 年实现了 Altair 8800 上的 BASIC 解释器


计算机科学家们已经在今天难以想象的计算力下开发惊奇的程序

## 1960s 的操作系统

> 能载入多个程序到内存且调度它们的管理程序。

为防止程序之间形成干扰，操作系统自然地将共享资源 (如设备) 以 API 形式管理起来

-   有了进程 (process) 的概念
-   进程在执行 I/O 时，可以将 CPU 让给另一个进程
    -   在多个地址空间隔离的程序之间切换
    -   虚拟存储使一个程序出 bug 不会 crash 整个系统

---

操作系统中自然地增加进程管理 API

-   既然可以在程序之间切换，为什么不让它们定时切换呢？
-   Multics (MIT, 1965)：现代分时操作系统诞生

#   (How): 怎么学操作系统？